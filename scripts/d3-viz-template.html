<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Espada ‚Äî AWS Infrastructure Topology</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      --bg: #0a0e1a; --surface: #111827; --surface2: #1e293b; --border: #334155;
      --text: #e2e8f0; --text2: #94a3b8; --text3: #64748b; --accent: #3b82f6;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: var(--bg); color: var(--text); font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; overflow: hidden; }

    /* Header */
    #header {
      position: fixed; top: 0; left: 0; right: 0; z-index: 20;
      padding: 14px 24px; display: flex; justify-content: space-between; align-items: center;
      background: linear-gradient(180deg, var(--bg) 70%, transparent);
      backdrop-filter: blur(12px);
    }
    #header h1 { font-size: 16px; font-weight: 700; letter-spacing: -0.3px; }
    #header h1 .brand { color: var(--accent); }
    #header .subtitle { font-size: 11px; color: var(--text3); margin-top: 2px; }

    /* Controls bar */
    #controls {
      display: flex; gap: 8px; align-items: center;
    }
    #controls button, #controls select {
      background: var(--surface2); border: 1px solid var(--border); color: var(--text);
      padding: 6px 12px; border-radius: 6px; font-size: 11px; cursor: pointer;
      transition: all 0.15s;
    }
    #controls button:hover, #controls select:hover { background: #293548; border-color: var(--accent); }
    #controls button.active { background: var(--accent); border-color: var(--accent); color: #fff; }
    #search-box {
      background: var(--surface2); border: 1px solid var(--border); color: var(--text);
      padding: 6px 10px; border-radius: 6px; font-size: 11px; width: 160px; outline: none;
    }
    #search-box:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(59,130,246,0.2); }
    #search-box::placeholder { color: var(--text3); }

    /* Legend */
    #legend {
      position: fixed; top: 56px; left: 24px; z-index: 15;
      display: flex; gap: 10px; flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text2); cursor: pointer; padding: 3px 8px; border-radius: 4px; transition: all 0.15s; }
    .legend-item:hover { background: var(--surface2); }
    .legend-item.dimmed { opacity: 0.3; }
    .legend-dot { width: 8px; height: 8px; border-radius: 50%; box-shadow: 0 0 6px currentColor; }

    /* Sidebar */
    #sidebar {
      position: fixed; right: -360px; top: 0; bottom: 0; width: 360px; z-index: 25;
      background: var(--surface); border-left: 1px solid var(--border);
      transition: right 0.3s ease; overflow-y: auto; padding: 20px;
    }
    #sidebar.open { right: 0; }
    #sidebar .close-btn {
      position: absolute; top: 12px; right: 12px; background: none; border: none;
      color: var(--text3); cursor: pointer; font-size: 18px;
    }
    #sidebar h2 { font-size: 15px; font-weight: 600; margin-bottom: 16px; color: var(--text); }
    #sidebar .detail-section { margin-bottom: 16px; }
    #sidebar .detail-section h3 { font-size: 11px; text-transform: uppercase; color: var(--text3); letter-spacing: 0.5px; margin-bottom: 8px; }
    .detail-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 12px; }
    .detail-key { color: var(--text2); }
    .detail-val { color: var(--text); font-weight: 500; text-align: right; max-width: 200px; word-break: break-all; }
    .detail-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; }
    #neighbor-list { list-style: none; }
    #neighbor-list li { padding: 6px 8px; font-size: 11px; border-radius: 4px; cursor: pointer; margin: 2px 0; transition: background 0.1s; display: flex; align-items: center; gap: 6px; }
    #neighbor-list li:hover { background: var(--surface2); }
    .neighbor-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }

    /* Minimap */
    #minimap {
      position: fixed; bottom: 16px; right: 16px; z-index: 15;
      width: 180px; height: 120px; background: var(--surface);
      border: 1px solid var(--border); border-radius: 8px; overflow: hidden;
      box-shadow: 0 4px 24px rgba(0,0,0,0.4);
    }
    #minimap .viewport-rect { fill: none; stroke: var(--accent); stroke-width: 1.5; stroke-dasharray: 3,2; }

    /* Stats bar */
    #stats { position: fixed; bottom: 16px; left: 24px; font-size: 10px; color: var(--text3); z-index: 15; }
    #stats b { color: var(--accent); font-weight: 600; }

    /* Tooltip */
    #tooltip {
      position: fixed; display: none; background: var(--surface2); border: 1px solid var(--border);
      border-radius: 8px; padding: 10px 14px; font-size: 11px; max-width: 280px;
      pointer-events: none; z-index: 100; box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    #tooltip .tt-label { font-weight: 600; font-size: 13px; color: #f8fafc; margin-bottom: 4px; }
    #tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; margin-top: 2px; }
    #tooltip .tt-key { color: var(--text3); }
    #tooltip .tt-val { color: var(--text); font-weight: 500; }

    /* SVG styles */
    svg { width: 100vw; height: 100vh; }
    .hull { fill-opacity: 0.04; stroke-opacity: 0.15; stroke-width: 1.5; stroke-dasharray: 6,3; }
    .link { stroke-opacity: 0.3; transition: stroke-opacity 0.3s; }
    .link.highlighted { stroke-opacity: 0.9; }
    .link-label { font-size: 8px; fill: var(--text3); pointer-events: none; opacity: 0; transition: opacity 0.3s; }
    .link-label.visible { opacity: 1; }
    .node-label { font-size: 9px; fill: var(--text2); pointer-events: none; text-anchor: middle; }
    .node-glow { filter: url(#glow); }

    /* Animated particles on edges */
    .edge-particle { pointer-events: none; }
  </style>
</head>
<body>
  <div id="header">
    <div>
      <h1><span class="brand">Espada</span> Infrastructure Topology</h1>
      <div class="subtitle">Live scan &middot; AWS us-east-1 &middot; <span id="scan-time"></span></div>
    </div>
    <div id="controls">
      <input id="search-box" type="text" placeholder="Search resources..." />
      <select id="layout-select">
        <option value="force">Force</option>
        <option value="radial">Radial</option>
        <option value="cluster">Cluster</option>
      </select>
      <button id="btn-labels" class="active">Labels</button>
      <button id="btn-particles">Particles</button>
      <button id="btn-hulls" class="active">Groups</button>
      <button id="btn-orphans" class="active">Orphans</button>
      <button id="btn-reset">Reset</button>
    </div>
  </div>

  <div id="legend"></div>
  <div id="tooltip"></div>
  <div id="sidebar">
    <button class="close-btn" onclick="closeSidebar()">&times;</button>
    <h2 id="sidebar-title">Resource Details</h2>
    <div id="sidebar-content"></div>
  </div>
  <div id="minimap"><svg id="minimap-svg"></svg></div>
  <div id="stats"></div>
  <svg id="main-svg"></svg>

  <script>
    const graphData = GRAPH_DATA_PLACEHOLDER;
    const width = window.innerWidth;
    const height = window.innerHeight;

    // --- Color & Type Config ---
    const typeConfig = {
      'vpc':              { color: '#3b82f6', icon: '‚òÅ',  label: 'VPC',              shape: 'hexagon' },
      'subnet':           { color: '#22c55e', icon: '‚äû',  label: 'Subnet',           shape: 'circle' },
      'security-group':   { color: '#ef4444', icon: 'üõ°', label: 'Security Group',   shape: 'diamond' },
      'internet-gateway': { color: '#06b6d4', icon: 'üåê', label: 'Internet Gateway', shape: 'triangle' },
      'route-table':      { color: '#8b5cf6', icon: '‚Üî',  label: 'Route Table',      shape: 'square' },
      'iam-role':         { color: '#a855f7', icon: 'üë§', label: 'IAM Role',         shape: 'circle' },
      'storage':          { color: '#f59e0b', icon: 'üì¶', label: 'Storage',          shape: 'circle' },
      'custom':           { color: '#94a3b8', icon: '‚äü',  label: 'Network ACL',      shape: 'square' },
    };
    const relColors = {
      'runs-in': '#22c55e', 'attached-to': '#06b6d4',
      'secures': '#ef4444', 'deployed-at': '#8b5cf6',
    };

    // --- Derived Data ---
    const connectedIds = new Set();
    graphData.links.forEach(l => { connectedIds.add(l.source); connectedIds.add(l.target); });

    graphData.nodes.forEach(n => {
      const tc = typeConfig[n.resourceType] || typeConfig.custom;
      n._color = tc.color;
      n._icon = tc.icon;
      n._typeLabel = tc.label;
      n._connected = connectedIds.has(n.id);
      n._radius = n.resourceType === 'vpc' ? 32
        : n._connected ? 18
        : 10;
    });

    // --- SVG Setup ---
    const svg = d3.select('#main-svg').attr('width', width).attr('height', height);

    // Filters
    const defs = svg.append('defs');
    const glowFilter = defs.append('filter').attr('id', 'glow').attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
    glowFilter.append('feGaussianBlur').attr('in', 'SourceGraphic').attr('stdDeviation', 4).attr('result', 'blur');
    glowFilter.append('feMerge').selectAll('feMergeNode').data(['blur', 'SourceGraphic']).join('feMergeNode').attr('in', d => d);

    // Gradient background
    const bgGrad = defs.append('radialGradient').attr('id', 'bg-grad').attr('cx', '50%').attr('cy', '50%').attr('r', '60%');
    bgGrad.append('stop').attr('offset', '0%').attr('stop-color', '#111827');
    bgGrad.append('stop').attr('offset', '100%').attr('stop-color', '#0a0e1a');
    svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'url(#bg-grad)');

    // Grid pattern
    const gridSize = 40;
    const gridG = svg.append('g').attr('class', 'grid');
    for (let x = 0; x < width; x += gridSize) {
      gridG.append('line').attr('x1', x).attr('y1', 0).attr('x2', x).attr('y2', height).attr('stroke', '#1e293b').attr('stroke-width', 0.3);
    }
    for (let y = 0; y < height; y += gridSize) {
      gridG.append('line').attr('x1', 0).attr('y1', y).attr('x2', width).attr('y2', y).attr('stroke', '#1e293b').attr('stroke-width', 0.3);
    }

    const g = svg.append('g');

    // Arrow markers per relationship type
    Object.entries(relColors).forEach(([rel, color]) => {
      defs.append('marker').attr('id', `arrow-${rel}`).attr('viewBox', '0 -5 10 10')
        .attr('refX', 22).attr('refY', 0).attr('markerWidth', 7).attr('markerHeight', 7)
        .attr('orient', 'auto')
        .append('path').attr('d', 'M0,-4L10,0L0,4').attr('fill', color).attr('opacity', 0.7);
    });

    // Zoom
    const zoomBehavior = d3.zoom().scaleExtent([0.15, 6]).on('zoom', (event) => {
      g.attr('transform', event.transform);
      updateMinimap(event.transform);
    });
    svg.call(zoomBehavior);

    // --- Hull Groups ---
    const hullTypes = ['vpc-cluster', 'iam', 'storage'];
    function getHullGroup(n) {
      if (n._connected) return 'vpc-cluster';
      if (n.resourceType === 'iam-role') return 'iam';
      if (n.resourceType === 'storage') return 'storage';
      return null;
    }
    const hullColors = { 'vpc-cluster': '#3b82f6', 'iam': '#a855f7', 'storage': '#f59e0b' };
    const hullLabels = { 'vpc-cluster': 'VPC Cluster', 'iam': 'Orphaned IAM Roles', 'storage': 'Orphaned Storage' };

    const hullG = g.append('g').attr('class', 'hulls');

    function updateHulls() {
      if (!showHulls) { hullG.selectAll('path').remove(); hullG.selectAll('text').remove(); return; }
      hullG.selectAll('path').remove();
      hullG.selectAll('text').remove();

      for (const hType of hullTypes) {
        const pts = graphData.nodes.filter(n => getHullGroup(n) === hType).map(n => [n.x, n.y]);
        if (pts.length < 3) continue;
        const hull = d3.polygonHull(pts);
        if (!hull) continue;

        // Expand hull
        const cx = d3.mean(hull, p => p[0]);
        const cy = d3.mean(hull, p => p[1]);
        const expanded = hull.map(p => [
          cx + (p[0] - cx) * 1.25,
          cy + (p[1] - cy) * 1.25,
        ]);

        hullG.append('path')
          .attr('d', `M${expanded.map(p => p.join(',')).join('L')}Z`)
          .attr('class', 'hull')
          .attr('fill', hullColors[hType])
          .attr('stroke', hullColors[hType]);

        hullG.append('text')
          .attr('x', cx).attr('y', d3.min(expanded, p => p[1]) - 8)
          .attr('text-anchor', 'middle')
          .attr('fill', hullColors[hType])
          .attr('opacity', 0.4)
          .attr('font-size', 10)
          .attr('font-weight', 600)
          .text(hullLabels[hType]);
      }
    }

    // --- Links ---
    const linkG = g.append('g');
    const link = linkG.selectAll('line').data(graphData.links).join('line')
      .attr('class', 'link')
      .attr('stroke', d => relColors[d.relationship] || '#475569')
      .attr('stroke-width', d => d.confidence > 0.9 ? 2 : 1.2)
      .attr('stroke-dasharray', d => d.strokeDasharray || '')
      .attr('marker-end', d => `url(#arrow-${d.relationship})`);

    const linkLabelG = g.append('g');
    const linkLabel = linkLabelG.selectAll('text').data(graphData.links).join('text')
      .attr('class', 'link-label')
      .text(d => d.label);

    // --- Particles ---
    const particleG = g.append('g');
    let particlesEnabled = false;
    let particleTimer = null;

    function startParticles() {
      if (particleTimer) return;
      particleTimer = d3.interval(() => {
        graphData.links.forEach(l => {
          if (Math.random() > 0.12) return;
          const color = relColors[l.relationship] || '#475569';
          const particle = particleG.append('circle')
            .attr('class', 'edge-particle')
            .attr('r', 2)
            .attr('fill', color)
            .attr('opacity', 0.8)
            .attr('cx', l.source.x)
            .attr('cy', l.source.y);

          particle.transition()
            .duration(1200 + Math.random() * 600)
            .ease(d3.easeLinear)
            .attr('cx', l.target.x)
            .attr('cy', l.target.y)
            .attr('opacity', 0)
            .attr('r', 1)
            .remove();
        });
      }, 400);
    }
    function stopParticles() {
      if (particleTimer) { particleTimer.stop(); particleTimer = null; }
      particleG.selectAll('*').remove();
    }

    // --- Nodes ---
    const nodeG = g.append('g');
    const node = nodeG.selectAll('g').data(graphData.nodes).join('g')
      .attr('cursor', 'pointer')
      .call(d3.drag()
        .on('start', (e, d) => { if (!e.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
        .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
        .on('end', (e, d) => { if (!e.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }));

    // Outer glow ring for connected nodes
    node.filter(d => d._connected).append('circle')
      .attr('r', d => d._radius + 6)
      .attr('fill', 'none')
      .attr('stroke', d => d._color)
      .attr('stroke-width', 1)
      .attr('opacity', 0.15)
      .attr('class', 'pulse-ring');

    // Main circle with gradient
    node.each(function(d) {
      const el = d3.select(this);
      const gradId = `grad-${d.id.replace(/[^a-zA-Z0-9]/g, '')}`.slice(0, 50);
      const grad = defs.append('radialGradient').attr('id', gradId);
      const c = d3.color(d._color);
      grad.append('stop').attr('offset', '0%').attr('stop-color', c.brighter(0.8));
      grad.append('stop').attr('offset', '100%').attr('stop-color', c.darker(0.3));

      el.append('circle')
        .attr('r', d._radius)
        .attr('fill', `url(#${gradId})`)
        .attr('stroke', c.brighter(0.3))
        .attr('stroke-width', d.resourceType === 'vpc' ? 2.5 : 1)
        .attr('opacity', d._connected ? 0.95 : 0.55);
    });

    // Icon
    node.filter(d => d._radius >= 14).append('text')
      .attr('text-anchor', 'middle').attr('dominant-baseline', 'central')
      .attr('font-size', d => d._radius * 0.65)
      .attr('opacity', 0.9)
      .text(d => d._icon);

    // Label
    const labels = node.append('text')
      .attr('class', 'node-label')
      .attr('dy', d => d._radius + 13)
      .attr('font-size', d => d._connected ? 9 : 7)
      .attr('opacity', d => d._connected ? 0.85 : 0.4)
      .text(d => {
        const name = d.label.length > 22 ? d.label.slice(0, 20) + '‚Ä¶' : d.label;
        return name;
      });

    // Cost badge for resources with cost > 0
    node.filter(d => d.costMonthly > 0).append('text')
      .attr('text-anchor', 'middle')
      .attr('dy', d => d._radius + 24)
      .attr('font-size', 8)
      .attr('fill', '#f59e0b')
      .attr('opacity', 0.7)
      .text(d => `$${d.costMonthly.toFixed(2)}/mo`);

    // --- Simulation ---
    const simulation = d3.forceSimulation(graphData.nodes)
      .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(d => {
        const src = typeof d.source === 'object' ? d.source : graphData.nodes.find(n => n.id === d.source);
        return src && src._connected ? 70 : 140;
      }))
      .force('charge', d3.forceManyBody().strength(d => d._connected ? -350 : -80))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(d => d._radius + 8))
      .force('x', d3.forceX(width / 2).strength(0.025))
      .force('y', d3.forceY(height / 2).strength(0.025))
      .alphaDecay(0.015)
      .on('tick', tick);

    function tick() {
      link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

      linkLabel.attr('x', d => (d.source.x + d.target.x) / 2)
        .attr('y', d => (d.source.y + d.target.y) / 2 - 4);

      node.attr('transform', d => `translate(${d.x},${d.y})`);

      updateHulls();
      updateMinimapNodes();
    }

    // --- Tooltip ---
    const tooltip = document.getElementById('tooltip');
    node.on('mouseover', (event, d) => {
      tooltip.style.display = 'block';
      const orphanTag = !d._connected
        ? '<div class="tt-row"><span class="tt-key">‚ö† Status</span><span class="tt-val" style="color:#f59e0b">Orphaned</span></div>' : '';
      tooltip.innerHTML = `
        <div class="tt-label" style="color:${d._color}">${d._icon} ${d.label}</div>
        <div class="tt-row"><span class="tt-key">Type</span><span class="tt-val">${d._typeLabel}</span></div>
        <div class="tt-row"><span class="tt-key">Region</span><span class="tt-val">${d.region}</span></div>
        <div class="tt-row"><span class="tt-key">Cost</span><span class="tt-val">$${(d.costMonthly || 0).toFixed(2)}/mo</span></div>
        ${orphanTag}
      `;
    })
    .on('mousemove', e => { tooltip.style.left = (e.clientX + 14) + 'px'; tooltip.style.top = (e.clientY - 8) + 'px'; })
    .on('mouseout', () => { tooltip.style.display = 'none'; });

    // --- Click ‚Üí Sidebar ---
    let selectedNode = null;
    node.on('click', (event, d) => {
      event.stopPropagation();
      selectedNode = d;
      highlightNeighborhood(d);
      openSidebar(d);
    });
    svg.on('click', () => { clearHighlight(); closeSidebar(); });

    function highlightNeighborhood(d) {
      const neighborIds = new Set([d.id]);
      graphData.links.forEach(l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        if (sid === d.id) neighborIds.add(tid);
        if (tid === d.id) neighborIds.add(sid);
      });

      node.select('circle:nth-child(2)').transition().duration(300)
        .attr('opacity', n => neighborIds.has(n.id) ? 1 : 0.08);
      node.selectAll('.node-label').transition().duration(300)
        .attr('opacity', n => neighborIds.has(n.id) ? 1 : 0.05);

      link.classed('highlighted', l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        return sid === d.id || tid === d.id;
      });
      link.transition().duration(300)
        .attr('stroke-opacity', l => {
          const sid = typeof l.source === 'object' ? l.source.id : l.source;
          const tid = typeof l.target === 'object' ? l.target.id : l.target;
          return (sid === d.id || tid === d.id) ? 0.9 : 0.05;
        });

      linkLabel.classed('visible', l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        return sid === d.id || tid === d.id;
      });
    }

    function clearHighlight() {
      selectedNode = null;
      node.select('circle:nth-child(2)').transition().duration(300)
        .attr('opacity', d => d._connected ? 0.95 : 0.55);
      node.selectAll('.node-label').transition().duration(300)
        .attr('opacity', d => d._connected ? 0.85 : 0.4);
      link.classed('highlighted', false).transition().duration(300).attr('stroke-opacity', 0.3);
      linkLabel.classed('visible', false);
    }

    function openSidebar(d) {
      document.getElementById('sidebar').classList.add('open');
      document.getElementById('sidebar-title').innerHTML = `<span style="color:${d._color}">${d._icon}</span> ${d.label}`;

      const neighbors = [];
      graphData.links.forEach(l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        if (sid === d.id) {
          const t = graphData.nodes.find(n => n.id === tid);
          if (t) neighbors.push({ node: t, rel: l.relationship, dir: 'outbound' });
        }
        if (tid === d.id) {
          const s = graphData.nodes.find(n => n.id === sid);
          if (s) neighbors.push({ node: s, rel: l.relationship, dir: 'inbound' });
        }
      });

      const statusColor = d._connected ? '#22c55e' : '#f59e0b';
      const statusText = d._connected ? 'Connected' : 'Orphaned';

      let html = `
        <div class="detail-section">
          <h3>Properties</h3>
          <div class="detail-row"><span class="detail-key">Type</span><span class="detail-val"><span class="detail-badge" style="background:${d._color}33;color:${d._color}">${d._typeLabel}</span></span></div>
          <div class="detail-row"><span class="detail-key">Provider</span><span class="detail-val">${d.provider.toUpperCase()}</span></div>
          <div class="detail-row"><span class="detail-key">Region</span><span class="detail-val">${d.region}</span></div>
          <div class="detail-row"><span class="detail-key">Status</span><span class="detail-val"><span class="detail-badge" style="background:${statusColor}22;color:${statusColor}">${statusText}</span></span></div>
          <div class="detail-row"><span class="detail-key">Monthly Cost</span><span class="detail-val">$${(d.costMonthly || 0).toFixed(2)}</span></div>
          <div class="detail-row"><span class="detail-key">Full ID</span><span class="detail-val" style="font-size:10px">${d.id}</span></div>
        </div>
      `;

      if (neighbors.length > 0) {
        html += `<div class="detail-section"><h3>Connections (${neighbors.length})</h3><ul id="neighbor-list">`;
        neighbors.forEach(({ node: nb, rel, dir }) => {
          const arrow = dir === 'outbound' ? '‚Üí' : '‚Üê';
          html += `<li onclick="focusNode('${nb.id}')"><span class="neighbor-dot" style="background:${nb._color}"></span>${arrow} <b>${rel}</b> ${nb.label}</li>`;
        });
        html += '</ul></div>';
      } else {
        html += '<div class="detail-section"><h3>Connections</h3><p style="font-size:11px;color:var(--text3)">No connections ‚Äî this resource is orphaned and may be a cleanup candidate.</p></div>';
      }

      document.getElementById('sidebar-content').innerHTML = html;
    }

    window.closeSidebar = () => { document.getElementById('sidebar').classList.remove('open'); };
    window.focusNode = (id) => {
      const n = graphData.nodes.find(n => n.id === id);
      if (!n) return;
      highlightNeighborhood(n);
      openSidebar(n);
      svg.transition().duration(500).call(
        zoomBehavior.transform,
        d3.zoomIdentity.translate(width/2 - n.x, height/2 - n.y).scale(1.5)
      );
    };

    // --- Legend ---
    const legendEl = document.getElementById('legend');
    const activeTypes = new Set(Object.keys(typeConfig));
    Object.entries(typeConfig).forEach(([type, cfg]) => {
      if (!graphData.nodes.some(n => n.resourceType === type)) return;
      const count = graphData.nodes.filter(n => n.resourceType === type).length;
      const item = document.createElement('div');
      item.className = 'legend-item';
      item.innerHTML = `<div class="legend-dot" style="background:${cfg.color};color:${cfg.color}"></div>${cfg.label} (${count})`;
      item.onclick = () => {
        if (activeTypes.has(type)) { activeTypes.delete(type); item.classList.add('dimmed'); }
        else { activeTypes.add(type); item.classList.remove('dimmed'); }
        node.transition().duration(300)
          .attr('opacity', d => activeTypes.has(d.resourceType) ? 1 : 0.05);
      };
      legendEl.appendChild(item);
    });

    // --- Controls ---
    let showLabels = true, showHulls = true, showOrphans = true;

    document.getElementById('btn-labels').onclick = function() {
      showLabels = !showLabels;
      this.classList.toggle('active');
      labels.transition().duration(200).attr('opacity', showLabels ? (d => d._connected ? 0.85 : 0.4) : 0);
    };

    document.getElementById('btn-particles').onclick = function() {
      particlesEnabled = !particlesEnabled;
      this.classList.toggle('active');
      particlesEnabled ? startParticles() : stopParticles();
    };

    document.getElementById('btn-hulls').onclick = function() {
      showHulls = !showHulls;
      this.classList.toggle('active');
      updateHulls();
    };

    document.getElementById('btn-orphans').onclick = function() {
      showOrphans = !showOrphans;
      this.classList.toggle('active');
      node.transition().duration(300)
        .attr('opacity', d => (!d._connected && !showOrphans) ? 0 : 1);
    };

    document.getElementById('btn-reset').onclick = () => {
      clearHighlight();
      closeSidebar();
      svg.transition().duration(500).call(zoomBehavior.transform, d3.zoomIdentity);
      simulation.alpha(0.5).restart();
    };

    // Search
    document.getElementById('search-box').addEventListener('input', function() {
      const q = this.value.toLowerCase().trim();
      if (!q) { clearHighlight(); return; }
      node.select('circle:nth-child(2)').transition().duration(200)
        .attr('opacity', d => d.label.toLowerCase().includes(q) || d.resourceType.includes(q) ? 1 : 0.06);
      node.selectAll('.node-label').transition().duration(200)
        .attr('opacity', d => d.label.toLowerCase().includes(q) || d.resourceType.includes(q) ? 1 : 0.06);
    });

    // Layout switch
    document.getElementById('layout-select').addEventListener('change', function() {
      const layout = this.value;
      simulation.stop();

      if (layout === 'radial') {
        const connNodes = graphData.nodes.filter(n => n._connected);
        const orphNodes = graphData.nodes.filter(n => !n._connected);
        const vpcNode = graphData.nodes.find(n => n.resourceType === 'vpc');
        if (vpcNode) { vpcNode.fx = width / 2; vpcNode.fy = height / 2; }
        connNodes.filter(n => n !== vpcNode).forEach((n, i) => {
          const angle = (2 * Math.PI * i) / (connNodes.length - 1);
          n.fx = width / 2 + 180 * Math.cos(angle);
          n.fy = height / 2 + 180 * Math.sin(angle);
        });
        orphNodes.forEach((n, i) => {
          const angle = (2 * Math.PI * i) / orphNodes.length;
          n.fx = width / 2 + 380 * Math.cos(angle);
          n.fy = height / 2 + 380 * Math.sin(angle);
        });
        simulation.alpha(0.5).restart();
        setTimeout(() => {
          graphData.nodes.forEach(n => { n.fx = null; n.fy = null; });
        }, 2000);
      } else if (layout === 'cluster') {
        const groups = { connected: [], iam: [], storage: [] };
        graphData.nodes.forEach(n => {
          if (n._connected) groups.connected.push(n);
          else if (n.resourceType === 'iam-role') groups.iam.push(n);
          else groups.storage.push(n);
        });
        const centers = { connected: [width * 0.35, height * 0.45], iam: [width * 0.7, height * 0.35], storage: [width * 0.7, height * 0.7] };
        Object.entries(groups).forEach(([gname, nodes]) => {
          const [cx, cy] = centers[gname];
          nodes.forEach((n, i) => {
            const angle = (2 * Math.PI * i) / Math.max(nodes.length, 1);
            const r = gname === 'connected' ? 150 : 80;
            n.fx = cx + r * Math.cos(angle);
            n.fy = cy + r * Math.sin(angle);
          });
        });
        simulation.alpha(0.5).restart();
        setTimeout(() => { graphData.nodes.forEach(n => { n.fx = null; n.fy = null; }); }, 2000);
      } else {
        graphData.nodes.forEach(n => { n.fx = null; n.fy = null; });
        simulation.force('center', d3.forceCenter(width / 2, height / 2));
        simulation.alpha(0.8).restart();
      }
    });

    // --- Minimap ---
    const mmSvg = d3.select('#minimap-svg').attr('width', 180).attr('height', 120);
    const mmScale = 0.08;
    const mmG = mmSvg.append('g').attr('transform', `translate(90,60) scale(${mmScale})`);
    const mmNodes = mmG.selectAll('circle').data(graphData.nodes).join('circle')
      .attr('r', d => d._radius * 0.8)
      .attr('fill', d => d._color)
      .attr('opacity', 0.7);
    const mmViewport = mmSvg.append('rect').attr('class', 'viewport-rect');

    function updateMinimapNodes() {
      mmNodes.attr('cx', d => d.x).attr('cy', d => d.y);
    }
    function updateMinimap(transform) {
      const vw = width / transform.k;
      const vh = height / transform.k;
      const vx = -transform.x / transform.k;
      const vy = -transform.y / transform.k;
      mmViewport
        .attr('x', 90 + vx * mmScale).attr('y', 60 + vy * mmScale)
        .attr('width', vw * mmScale).attr('height', vh * mmScale);
    }
    updateMinimap(d3.zoomIdentity);

    // --- Stats ---
    const orphanCount = graphData.nodes.filter(n => !n._connected).length;
    const totalCost = graphData.nodes.reduce((s, n) => s + (n.costMonthly || 0), 0);
    document.getElementById('stats').innerHTML =
      `<b>Espada</b> exportVisualization (d3-force) ¬∑ ${graphData.nodes.length} nodes ¬∑ ${graphData.links.length} edges ¬∑ ${orphanCount} orphaned ¬∑ $${totalCost.toFixed(2)}/mo ¬∑ Click node for details`;
    document.getElementById('scan-time').textContent = new Date().toLocaleString();

    // --- Pulse Animation ---
    function pulseRings() {
      d3.selectAll('.pulse-ring')
        .transition().duration(2000).attr('r', d => d._radius + 14).attr('opacity', 0)
        .transition().duration(0).attr('r', d => d._radius + 6).attr('opacity', 0.15)
        .on('end', pulseRings);
    }
    pulseRings();

    // Initial zoom fit
    setTimeout(() => {
      const bounds = g.node().getBBox();
      const dx = bounds.width, dy = bounds.height;
      const x = bounds.x, y = bounds.y;
      const scale = 0.85 / Math.max(dx / width, dy / height);
      const translate = [width / 2 - scale * (x + dx / 2), height / 2 - scale * (y + dy / 2)];
      svg.transition().duration(1000).call(
        zoomBehavior.transform,
        d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
      );
    }, 2500);
  </script>
</body>
</html>

/**
 * Terraform Import Planner — high-level orchestration for importing existing
 * infrastructure into Terraform state.
 *
 * Supports two modes:
 *   1. TF 1.5+ native `import {}` blocks (HCL-based, recommended)
 *   2. Sequential `terraform import` commands (legacy, TF < 1.5)
 *
 * Uses codify.ts for dependency ordering and hcl-generator.ts for resource
 * block generation. This module adds:
 *   - Import block generation (TF 1.5+ syntax)
 *   - Import validation and dry-run
 *   - Batch import script generation
 *   - Import status tracking
 */

import type { CodifyNode } from "./hcl-generator.js";
import { generateResourceBlock } from "./hcl-generator.js";
import { filterNodes, type CodifyFilter } from "./codify.js";
import { planImportOrder, generateOrderedImports } from "./codify.js";

// ── Types ───────────────────────────────────────────────────────────────────────

export interface ImportBlock {
  /** Terraform resource address (e.g. "aws_instance.web"). */
  to: string;
  /** Cloud-native resource ID (e.g. "i-1234567890abcdef0"). */
  id: string;
  /** Optional provider alias. */
  provider?: string;
}

export interface ImportPlan {
  /** TF version mode. */
  mode: "hcl-import" | "cli-import";
  /** Ordered list of import blocks/commands. */
  imports: ImportPlanEntry[];
  /** Total resources to import. */
  totalResources: number;
  /** Generated at timestamp. */
  generatedAt: string;
  /** Applied filter. */
  filter?: CodifyFilter;
}

export interface ImportPlanEntry {
  /** Resource address. */
  address: string;
  /** Native resource ID. */
  nativeId: string;
  /** Resource type. */
  resourceType: string;
  /** Cloud provider. */
  provider: string;
  /** Position in dependency order (0-based). */
  order: number;
  /** Dependencies that must be imported first. */
  dependsOn: string[];
}

export type ImportStatus = "pending" | "importing" | "imported" | "failed" | "skipped";

export interface ImportStatusEntry {
  address: string;
  nativeId: string;
  status: ImportStatus;
  error?: string;
  importedAt?: string;
}

export interface ImportResult {
  plan: ImportPlan;
  statuses: ImportStatusEntry[];
  successCount: number;
  failureCount: number;
  skippedCount: number;
}

// ── Import Block Generation (TF 1.5+) ──────────────────────────────────────────

/**
 * Generate TF 1.5+ `import {}` blocks for a set of graph nodes.
 * Blocks are ordered by dependency (dependencies first).
 */
export function generateImportBlocks(
  nodes: CodifyNode[],
  edges: Array<{ sourceId: string; targetId: string; relationshipType?: string }>,
  filter?: CodifyFilter,
): ImportBlock[] {
  const filtered = filter ? filterNodes(nodes, filter) : nodes;
  const ordered = planImportOrder(filtered, edges);

  return ordered.map((node) => {
    const resource = generateResourceBlock(node);
    return {
      to: resource?.address ?? `${inferTfType(node)}.${sanitizeName(node.name)}`,
      id: node.nativeId,
      provider: node.provider !== "aws" ? `${node.provider}` : undefined,
    };
  }).filter((block) => !!block.to && !!block.id);
}

/**
 * Render import blocks as HCL content (TF 1.5+ syntax).
 *
 * Output:
 * ```hcl
 * import {
 *   to = aws_instance.web
 *   id = "i-1234567890abcdef0"
 * }
 * ```
 */
export function renderImportBlocksHCL(blocks: ImportBlock[]): string {
  const lines: string[] = [
    "# Terraform Import Blocks",
    "# Generated by Espada — dependency-ordered",
    `# Generated: ${new Date().toISOString()}`,
    `# Resources: ${blocks.length}`,
    "",
  ];

  for (const block of blocks) {
    lines.push("import {");
    lines.push(`  to = ${block.to}`);
    lines.push(`  id = "${block.id}"`);
    if (block.provider) {
      lines.push(`  provider = ${block.provider}`);
    }
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

// ── CLI Import Script (Legacy) ──────────────────────────────────────────────────

/**
 * Generate a bash script with sequential `terraform import` commands.
 * Commands are ordered by dependency (dependencies first).
 */
export function generateImportScript(
  nodes: CodifyNode[],
  edges: Array<{ sourceId: string; targetId: string; relationshipType?: string }>,
  filter?: CodifyFilter,
): string {
  const filtered = filter ? filterNodes(nodes, filter) : nodes;
  const cmds = generateOrderedImports(filtered, edges);

  const lines = [
    "#!/usr/bin/env bash",
    "set -euo pipefail",
    "",
    "# Terraform import script — dependency-ordered",
    `# Generated: ${new Date().toISOString()}`,
    `# Resources: ${cmds.length}`,
    "",
    '# Usage: bash import.sh [--dry-run]',
    "",
    'DRY_RUN="${1:-}"',
    "",
    'run_import() {',
    '  local cmd="$1"',
    '  local step="$2"',
    '  local total="$3"',
    '  echo "[$step/$total] $cmd"',
    '  if [[ "$DRY_RUN" != "--dry-run" ]]; then',
    '    eval "$cmd" || { echo "FAILED: $cmd"; exit 1; }',
    "  fi",
    "}",
    "",
  ];

  for (let i = 0; i < cmds.length; i++) {
    lines.push(`run_import '${cmds[i].replace(/'/g, "\\'")}' ${i + 1} ${cmds.length}`);
  }

  lines.push("");
  lines.push(`echo "Import complete: ${cmds.length} resources imported."`);

  return lines.join("\n");
}

// ── Import Plan ─────────────────────────────────────────────────────────────────

/**
 * Create a full import plan with dependency ordering and metadata.
 */
export function createImportPlan(
  nodes: CodifyNode[],
  edges: Array<{ sourceId: string; targetId: string; relationshipType?: string }>,
  opts: {
    mode?: "hcl-import" | "cli-import";
    filter?: CodifyFilter;
  } = {},
): ImportPlan {
  const mode = opts.mode ?? "hcl-import";
  const filtered = opts.filter ? filterNodes(nodes, opts.filter) : nodes;
  const ordered = planImportOrder(filtered, edges);

  // Build dependency lookup for each node
  const dependsOnMap = new Map<string, string[]>();
  for (const edge of edges) {
    if (edge.relationshipType === "depends-on") {
      const deps = dependsOnMap.get(edge.sourceId) ?? [];
      deps.push(edge.targetId);
      dependsOnMap.set(edge.sourceId, deps);
    }
  }

  const imports: ImportPlanEntry[] = ordered.map((node, i) => ({
    address: generateResourceBlock(node)?.address ?? `${inferTfType(node)}.${sanitizeName(node.name)}`,
    nativeId: node.nativeId,
    resourceType: node.resourceType,
    provider: node.provider,
    order: i,
    dependsOn: (dependsOnMap.get(node.id) ?? [])
      .filter((depId) => ordered.some((n) => n.id === depId))
      .map((depId) => {
        const depNode = ordered.find((n) => n.id === depId);
        return depNode
          ? (generateResourceBlock(depNode)?.address ?? depNode.name)
          : depId;
      }),
  }));

  return {
    mode,
    imports,
    totalResources: imports.length,
    generatedAt: new Date().toISOString(),
    filter: opts.filter,
  };
}

/**
 * Render an import plan as either HCL import blocks or a bash script.
 */
export function renderImportPlan(plan: ImportPlan): string {
  if (plan.mode === "hcl-import") {
    const blocks: ImportBlock[] = plan.imports.map((entry) => ({
      to: entry.address,
      id: entry.nativeId,
      provider: entry.provider !== "aws" ? entry.provider : undefined,
    }));
    return renderImportBlocksHCL(blocks);
  }

  // CLI mode — generate bash commands
  const lines = [
    "#!/usr/bin/env bash",
    "set -euo pipefail",
    "",
    "# Terraform import plan — dependency-ordered",
    `# Generated: ${plan.generatedAt}`,
    `# Resources: ${plan.totalResources}`,
    "",
  ];

  for (const entry of plan.imports) {
    lines.push(`# Step ${entry.order + 1}: ${entry.resourceType} (${entry.provider})`);
    if (entry.dependsOn.length > 0) {
      lines.push(`# Depends on: ${entry.dependsOn.join(", ")}`);
    }
    lines.push(`terraform import '${entry.address}' '${entry.nativeId}'`);
    lines.push("");
  }

  return lines.join("\n");
}

// ── Import Status Tracking ──────────────────────────────────────────────────────

/**
 * Initialize an import result tracker from a plan.
 */
export function initImportResult(plan: ImportPlan): ImportResult {
  return {
    plan,
    statuses: plan.imports.map((entry) => ({
      address: entry.address,
      nativeId: entry.nativeId,
      status: "pending",
    })),
    successCount: 0,
    failureCount: 0,
    skippedCount: 0,
  };
}

/**
 * Update the status of a single import entry.
 */
export function updateImportStatus(
  result: ImportResult,
  address: string,
  status: ImportStatus,
  error?: string,
): void {
  const entry = result.statuses.find((s) => s.address === address);
  if (!entry) return;

  entry.status = status;
  if (error) entry.error = error;
  if (status === "imported") entry.importedAt = new Date().toISOString();

  // Recalculate counts
  result.successCount = result.statuses.filter((s) => s.status === "imported").length;
  result.failureCount = result.statuses.filter((s) => s.status === "failed").length;
  result.skippedCount = result.statuses.filter((s) => s.status === "skipped").length;
}

/**
 * Get a summary string of import progress.
 */
export function importSummary(result: ImportResult): string {
  const total = result.plan.totalResources;
  const done = result.successCount + result.failureCount + result.skippedCount;
  const lines = [
    `Import Progress: ${done}/${total}`,
    `  Imported: ${result.successCount}`,
    `  Failed:   ${result.failureCount}`,
    `  Skipped:  ${result.skippedCount}`,
    `  Pending:  ${total - done}`,
  ];

  if (result.failureCount > 0) {
    lines.push("");
    lines.push("Failures:");
    for (const s of result.statuses.filter((s) => s.status === "failed")) {
      lines.push(`  ${s.address}: ${s.error ?? "unknown error"}`);
    }
  }

  return lines.join("\n");
}

// ── Helpers ─────────────────────────────────────────────────────────────────────

/** Infer a Terraform resource type from a CodifyNode's metadata. */
function inferTfType(node: CodifyNode): string {
  const tfType = (node.metadata as Record<string, unknown>).tfType;
  if (typeof tfType === "string") return tfType;

  // Fallback: provider_resourceType
  const prefix = node.provider === "azure" ? "azurerm" : node.provider === "gcp" ? "google" : node.provider;
  return `${prefix}_${node.resourceType}`;
}

/** Sanitize a name for use as a Terraform identifier. */
function sanitizeName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9_]/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_|_$/g, "")
    || "resource";
}

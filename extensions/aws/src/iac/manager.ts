/**
 * AWS IaC (Infrastructure as Code) Manager
 *
 * Provides capabilities for:
 * - Generating Terraform configurations from resource definitions
 * - Generating CloudFormation templates
 * - Detecting drift between IaC and deployed resources
 * - Exporting existing infrastructure to IaC format
 * - Planning and applying infrastructure changes
 */

import type {
  IaCManagerConfig,
  IaCResourceDefinition,
  InfrastructureTemplate,
  TerraformGenerationOptions,
  TerraformGenerationResult,
  CloudFormationGenerationOptions,
  CloudFormationGenerationResult,
  DriftDetectionOptions,
  DriftDetectionResult,
  ResourceDrift,
  DriftStatus,
  StateExportOptions,
  StateExportResult,
  DiscoveredResource,
  InfrastructurePlan,
  ResourceChange,
  ApplyOptions,
  ApplyResult,
  IaCOperationResult,
  AWSResourceType,
  EC2InstanceDefinition,
  VPCDefinition,
  SubnetDefinition,
  SecurityGroupDefinition,
  RDSInstanceDefinition,
  S3BucketDefinition,
  LambdaFunctionDefinition,
  IAMRoleDefinition,
  ALBDefinition,
  ASGDefinition,
} from './types.js';

// =============================================================================
// IaC Manager Class
// =============================================================================

export class IaCManager {
  private config: IaCManagerConfig;

  constructor(config: IaCManagerConfig = {}) {
    this.config = {
      defaultCloudFormationFormat: 'yaml',
      terraformVersion: '>= 1.0',
      awsProviderVersion: '~> 5.0',
      includeComments: true,
      defaultRegion: 'us-east-1',
      ...config,
    };
  }

  // ===========================================================================
  // Terraform Generation
  // ===========================================================================

  /**
   * Generate Terraform configuration from resource definitions
   */
  async generateTerraform(
    template: InfrastructureTemplate,
    options: TerraformGenerationOptions = {}
  ): Promise<TerraformGenerationResult> {
    const mergedOptions: TerraformGenerationOptions = {
      terraformVersion: this.config.terraformVersion,
      awsProviderVersion: this.config.awsProviderVersion,
      includeComments: this.config.includeComments,
      region: this.config.defaultRegion,
      ...options,
    };

    try {
      const files: Record<string, string> = {};
      const warnings: string[] = [];
      const errors: string[] = [];

      // Generate provider configuration
      const providerTf = this.generateTerraformProvider(mergedOptions);
      files['provider.tf'] = providerTf;

      // Generate backend configuration if specified
      if (mergedOptions.backend) {
        const backendTf = this.generateTerraformBackend(mergedOptions.backend);
        files['backend.tf'] = backendTf;
      }

      // Generate variables if needed
      if (mergedOptions.includeVariables && template.variables) {
        const variablesTf = this.generateTerraformVariables(template.variables);
        files['variables.tf'] = variablesTf;
      }

      // Generate main resources
      const mainTf = this.generateTerraformResources(template.resources, mergedOptions, warnings);
      files['main.tf'] = mainTf;

      // Generate outputs if needed
      if (mergedOptions.includeOutputs && template.outputs) {
        const outputsTf = this.generateTerraformOutputs(template.outputs);
        files['outputs.tf'] = outputsTf;
      }

      return {
        success: true,
        mainTf: files['main.tf'],
        providerTf: files['provider.tf'],
        variablesTf: files['variables.tf'],
        outputsTf: files['outputs.tf'],
        backendTf: files['backend.tf'],
        files,
        warnings: warnings.length > 0 ? warnings : undefined,
        resourceCount: template.resources.length,
        message: `Successfully generated Terraform configuration with ${template.resources.length} resources`,
      };
    } catch (error) {
      return {
        success: false,
        errors: [String(error)],
        message: `Failed to generate Terraform: ${error}`,
      };
    }
  }

  /**
   * Generate Terraform provider block
   */
  private generateTerraformProvider(options: TerraformGenerationOptions): string {
    const lines: string[] = [];

    if (options.includeComments) {
      lines.push('# Terraform and Provider Configuration');
      lines.push('# Generated by Espada AWS Extension');
      lines.push('');
    }

    lines.push('terraform {');
    lines.push(`  required_version = "${options.terraformVersion || '>= 1.0'}"`);
    lines.push('');
    lines.push('  required_providers {');
    lines.push('    aws = {');
    lines.push('      source  = "hashicorp/aws"');
    lines.push(`      version = "${options.awsProviderVersion || '~> 5.0'}"`);
    lines.push('    }');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    lines.push('provider "aws" {');
    lines.push(`  region = "${options.region || 'us-east-1'}"`);
    if (options.profile) {
      lines.push(`  profile = "${options.profile}"`);
    }
    if (this.config.defaultTags && Object.keys(this.config.defaultTags).length > 0) {
      lines.push('');
      lines.push('  default_tags {');
      lines.push('    tags = {');
      for (const [key, value] of Object.entries(this.config.defaultTags)) {
        lines.push(`      ${key} = "${value}"`);
      }
      lines.push('    }');
      lines.push('  }');
    }
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate Terraform backend configuration
   */
  private generateTerraformBackend(backend: { type: string; config: Record<string, unknown> }): string {
    const lines: string[] = [];

    lines.push('terraform {');
    lines.push(`  backend "${backend.type}" {`);
    for (const [key, value] of Object.entries(backend.config)) {
      if (typeof value === 'string') {
        lines.push(`    ${key} = "${value}"`);
      } else if (typeof value === 'boolean') {
        lines.push(`    ${key} = ${value}`);
      } else if (typeof value === 'number') {
        lines.push(`    ${key} = ${value}`);
      }
    }
    lines.push('  }');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate Terraform variables
   */
  private generateTerraformVariables(variables: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [name, def] of Object.entries(variables)) {
      const varDef = def as { type?: string; description?: string; default?: unknown };
      lines.push(`variable "${name}" {`);
      if (varDef.type) {
        lines.push(`  type = ${varDef.type}`);
      }
      if (varDef.description) {
        lines.push(`  description = "${varDef.description}"`);
      }
      if (varDef.default !== undefined) {
        if (typeof varDef.default === 'string') {
          lines.push(`  default = "${varDef.default}"`);
        } else {
          lines.push(`  default = ${JSON.stringify(varDef.default)}`);
        }
      }
      lines.push('}');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate Terraform resources
   */
  private generateTerraformResources(
    resources: IaCResourceDefinition[],
    options: TerraformGenerationOptions,
    warnings: string[]
  ): string {
    const lines: string[] = [];

    if (options.includeComments) {
      lines.push('# Main Infrastructure Resources');
      lines.push('# Generated by Espada AWS Extension');
      lines.push('');
    }

    for (const resource of resources) {
      const resourceLines = this.generateTerraformResource(resource, options, warnings);
      lines.push(...resourceLines);
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate a single Terraform resource
   */
  private generateTerraformResource(
    resource: IaCResourceDefinition,
    options: TerraformGenerationOptions,
    warnings: string[]
  ): string[] {
    const lines: string[] = [];
    const tfResourceType = this.getAWSResourceType(resource.type);

    if (!tfResourceType) {
      warnings.push(`Unknown resource type: ${resource.type}`);
      return lines;
    }

    if (options.includeComments) {
      lines.push(`# ${resource.name}`);
    }

    lines.push(`resource "${tfResourceType}" "${this.sanitizeName(resource.name)}" {`);

    // Add properties based on resource type
    const propertyLines = this.generateTerraformProperties(resource);
    lines.push(...propertyLines.map(l => `  ${l}`));

    // Add tags
    if (resource.tags && Object.keys(resource.tags).length > 0) {
      lines.push('');
      lines.push('  tags = {');
      for (const [key, value] of Object.entries(resource.tags)) {
        lines.push(`    ${key} = "${value}"`);
      }
      lines.push('  }');
    }

    // Add depends_on
    if (resource.dependsOn && resource.dependsOn.length > 0) {
      lines.push('');
      lines.push('  depends_on = [');
      for (const dep of resource.dependsOn) {
        lines.push(`    ${dep},`);
      }
      lines.push('  ]');
    }

    lines.push('}');

    return lines;
  }

  /**
   * Generate Terraform properties for a resource
   */
  private generateTerraformProperties(resource: IaCResourceDefinition): string[] {
    const lines: string[] = [];
    const props = resource.properties;

    switch (resource.type) {
      case 'ec2_instance': {
        const ec2 = resource as EC2InstanceDefinition;
        lines.push(`ami           = "${ec2.properties.ami}"`);
        lines.push(`instance_type = "${ec2.properties.instanceType}"`);
        if (ec2.properties.subnetId) lines.push(`subnet_id = "${ec2.properties.subnetId}"`);
        if (ec2.properties.keyName) lines.push(`key_name = "${ec2.properties.keyName}"`);
        if (ec2.properties.securityGroupIds) {
          lines.push(`vpc_security_group_ids = ${JSON.stringify(ec2.properties.securityGroupIds)}`);
        }
        if (ec2.properties.iamInstanceProfile) {
          lines.push(`iam_instance_profile = "${ec2.properties.iamInstanceProfile}"`);
        }
        if (ec2.properties.monitoring) lines.push(`monitoring = ${ec2.properties.monitoring}`);
        if (ec2.properties.ebsOptimized) lines.push(`ebs_optimized = ${ec2.properties.ebsOptimized}`);
        if (ec2.properties.rootBlockDevice) {
          lines.push('');
          lines.push('root_block_device {');
          lines.push(`  volume_size = ${ec2.properties.rootBlockDevice.volumeSize}`);
          lines.push(`  volume_type = "${ec2.properties.rootBlockDevice.volumeType}"`);
          if (ec2.properties.rootBlockDevice.encrypted) {
            lines.push(`  encrypted = ${ec2.properties.rootBlockDevice.encrypted}`);
          }
          if (ec2.properties.rootBlockDevice.deleteOnTermination !== undefined) {
            lines.push(`  delete_on_termination = ${ec2.properties.rootBlockDevice.deleteOnTermination}`);
          }
          lines.push('}');
        }
        break;
      }

      case 'ec2_vpc': {
        const vpc = resource as VPCDefinition;
        lines.push(`cidr_block = "${vpc.properties.cidrBlock}"`);
        if (vpc.properties.enableDnsSupport !== undefined) {
          lines.push(`enable_dns_support = ${vpc.properties.enableDnsSupport}`);
        }
        if (vpc.properties.enableDnsHostnames !== undefined) {
          lines.push(`enable_dns_hostnames = ${vpc.properties.enableDnsHostnames}`);
        }
        if (vpc.properties.instanceTenancy) {
          lines.push(`instance_tenancy = "${vpc.properties.instanceTenancy}"`);
        }
        break;
      }

      case 'ec2_subnet': {
        const subnet = resource as SubnetDefinition;
        lines.push(`vpc_id     = "${subnet.properties.vpcId}"`);
        lines.push(`cidr_block = "${subnet.properties.cidrBlock}"`);
        if (subnet.properties.availabilityZone) {
          lines.push(`availability_zone = "${subnet.properties.availabilityZone}"`);
        }
        if (subnet.properties.mapPublicIpOnLaunch !== undefined) {
          lines.push(`map_public_ip_on_launch = ${subnet.properties.mapPublicIpOnLaunch}`);
        }
        break;
      }

      case 'ec2_security_group': {
        const sg = resource as SecurityGroupDefinition;
        lines.push(`name        = "${resource.name}"`);
        lines.push(`description = "${sg.properties.description}"`);
        if (sg.properties.vpcId) lines.push(`vpc_id = "${sg.properties.vpcId}"`);
        
        if (sg.properties.ingressRules) {
          for (const rule of sg.properties.ingressRules) {
            lines.push('');
            lines.push('ingress {');
            lines.push(`  from_port   = ${rule.fromPort}`);
            lines.push(`  to_port     = ${rule.toPort}`);
            lines.push(`  protocol    = "${rule.protocol}"`);
            if (rule.cidrBlocks) {
              lines.push(`  cidr_blocks = ${JSON.stringify(rule.cidrBlocks)}`);
            }
            if (rule.description) {
              lines.push(`  description = "${rule.description}"`);
            }
            lines.push('}');
          }
        }

        if (sg.properties.egressRules) {
          for (const rule of sg.properties.egressRules) {
            lines.push('');
            lines.push('egress {');
            lines.push(`  from_port   = ${rule.fromPort}`);
            lines.push(`  to_port     = ${rule.toPort}`);
            lines.push(`  protocol    = "${rule.protocol}"`);
            if (rule.cidrBlocks) {
              lines.push(`  cidr_blocks = ${JSON.stringify(rule.cidrBlocks)}`);
            }
            lines.push('}');
          }
        }
        break;
      }

      case 'rds_instance': {
        const rds = resource as RDSInstanceDefinition;
        lines.push(`identifier     = "${rds.properties.identifier}"`);
        lines.push(`engine         = "${rds.properties.engine}"`);
        if (rds.properties.engineVersion) lines.push(`engine_version = "${rds.properties.engineVersion}"`);
        lines.push(`instance_class = "${rds.properties.instanceClass}"`);
        lines.push(`allocated_storage = ${rds.properties.allocatedStorage}`);
        if (rds.properties.storageType) lines.push(`storage_type = "${rds.properties.storageType}"`);
        lines.push(`username = "${rds.properties.username}"`);
        if (rds.properties.password) {
          lines.push(`password = "${rds.properties.password}" # Consider using secrets manager`);
        }
        if (rds.properties.dbName) lines.push(`db_name = "${rds.properties.dbName}"`);
        if (rds.properties.multiAz !== undefined) lines.push(`multi_az = ${rds.properties.multiAz}`);
        if (rds.properties.publiclyAccessible !== undefined) {
          lines.push(`publicly_accessible = ${rds.properties.publiclyAccessible}`);
        }
        if (rds.properties.subnetGroupName) {
          lines.push(`db_subnet_group_name = "${rds.properties.subnetGroupName}"`);
        }
        if (rds.properties.securityGroupIds) {
          lines.push(`vpc_security_group_ids = ${JSON.stringify(rds.properties.securityGroupIds)}`);
        }
        if (rds.properties.backupRetentionPeriod !== undefined) {
          lines.push(`backup_retention_period = ${rds.properties.backupRetentionPeriod}`);
        }
        if (rds.properties.skipFinalSnapshot !== undefined) {
          lines.push(`skip_final_snapshot = ${rds.properties.skipFinalSnapshot}`);
        }
        if (rds.properties.deletionProtection !== undefined) {
          lines.push(`deletion_protection = ${rds.properties.deletionProtection}`);
        }
        if (rds.properties.storageEncrypted !== undefined) {
          lines.push(`storage_encrypted = ${rds.properties.storageEncrypted}`);
        }
        break;
      }

      case 's3_bucket': {
        const s3 = resource as S3BucketDefinition;
        if (s3.properties.bucketName) {
          lines.push(`bucket = "${s3.properties.bucketName}"`);
        }
        break;
      }

      case 'lambda_function': {
        const lambda = resource as LambdaFunctionDefinition;
        lines.push(`function_name = "${lambda.properties.functionName}"`);
        lines.push(`runtime       = "${lambda.properties.runtime}"`);
        lines.push(`handler       = "${lambda.properties.handler}"`);
        lines.push(`role          = "${lambda.properties.role}"`);
        if (lambda.properties.s3Bucket) lines.push(`s3_bucket = "${lambda.properties.s3Bucket}"`);
        if (lambda.properties.s3Key) lines.push(`s3_key = "${lambda.properties.s3Key}"`);
        if (lambda.properties.filename) lines.push(`filename = "${lambda.properties.filename}"`);
        if (lambda.properties.memorySize) lines.push(`memory_size = ${lambda.properties.memorySize}`);
        if (lambda.properties.timeout) lines.push(`timeout = ${lambda.properties.timeout}`);
        if (lambda.properties.layers) {
          lines.push(`layers = ${JSON.stringify(lambda.properties.layers)}`);
        }
        if (lambda.properties.environment) {
          lines.push('');
          lines.push('environment {');
          lines.push('  variables = {');
          for (const [key, value] of Object.entries(lambda.properties.environment)) {
            lines.push(`    ${key} = "${value}"`);
          }
          lines.push('  }');
          lines.push('}');
        }
        if (lambda.properties.vpcConfig) {
          lines.push('');
          lines.push('vpc_config {');
          lines.push(`  subnet_ids         = ${JSON.stringify(lambda.properties.vpcConfig.subnetIds)}`);
          lines.push(`  security_group_ids = ${JSON.stringify(lambda.properties.vpcConfig.securityGroupIds)}`);
          lines.push('}');
        }
        break;
      }

      case 'iam_role': {
        const iam = resource as IAMRoleDefinition;
        lines.push(`name = "${iam.properties.name}"`);
        const assumePolicy = typeof iam.properties.assumeRolePolicy === 'string'
          ? iam.properties.assumeRolePolicy
          : JSON.stringify(iam.properties.assumeRolePolicy, null, 2);
        lines.push(`assume_role_policy = <<EOF`);
        lines.push(assumePolicy);
        lines.push('EOF');
        if (iam.properties.description) {
          lines.push(`description = "${iam.properties.description}"`);
        }
        if (iam.properties.managedPolicyArns) {
          lines.push(`managed_policy_arns = ${JSON.stringify(iam.properties.managedPolicyArns)}`);
        }
        break;
      }

      case 'alb': {
        const alb = resource as ALBDefinition;
        lines.push(`name               = "${alb.properties.name}"`);
        lines.push(`internal           = ${alb.properties.internal ?? false}`);
        lines.push(`load_balancer_type = "${alb.properties.loadBalancerType ?? 'application'}"`);
        if (alb.properties.securityGroups) {
          lines.push(`security_groups = ${JSON.stringify(alb.properties.securityGroups)}`);
        }
        lines.push(`subnets = ${JSON.stringify(alb.properties.subnets)}`);
        if (alb.properties.enableDeletionProtection !== undefined) {
          lines.push(`enable_deletion_protection = ${alb.properties.enableDeletionProtection}`);
        }
        break;
      }

      case 'asg': {
        const asg = resource as ASGDefinition;
        lines.push(`name                = "${asg.properties.name}"`);
        lines.push(`min_size            = ${asg.properties.minSize}`);
        lines.push(`max_size            = ${asg.properties.maxSize}`);
        lines.push(`desired_capacity    = ${asg.properties.desiredCapacity}`);
        lines.push(`vpc_zone_identifier = ${JSON.stringify(asg.properties.vpcZoneIdentifier)}`);
        if (asg.properties.launchTemplate) {
          lines.push('');
          lines.push('launch_template {');
          lines.push(`  id      = "${asg.properties.launchTemplate.id}"`);
          lines.push(`  version = "${asg.properties.launchTemplate.version}"`);
          lines.push('}');
        }
        if (asg.properties.targetGroupArns) {
          lines.push(`target_group_arns = ${JSON.stringify(asg.properties.targetGroupArns)}`);
        }
        if (asg.properties.healthCheckType) {
          lines.push(`health_check_type = "${asg.properties.healthCheckType}"`);
        }
        if (asg.properties.healthCheckGracePeriod !== undefined) {
          lines.push(`health_check_grace_period = ${asg.properties.healthCheckGracePeriod}`);
        }
        break;
      }

      default:
        // Generic property generation
        for (const [key, value] of Object.entries(props)) {
          if (typeof value === 'string') {
            lines.push(`${this.toSnakeCase(key)} = "${value}"`);
          } else if (typeof value === 'boolean' || typeof value === 'number') {
            lines.push(`${this.toSnakeCase(key)} = ${value}`);
          } else if (Array.isArray(value)) {
            lines.push(`${this.toSnakeCase(key)} = ${JSON.stringify(value)}`);
          }
        }
    }

    return lines;
  }

  /**
   * Generate Terraform outputs
   */
  private generateTerraformOutputs(outputs: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [name, def] of Object.entries(outputs)) {
      const outDef = def as { value: string; description?: string; sensitive?: boolean };
      lines.push(`output "${name}" {`);
      lines.push(`  value = ${outDef.value}`);
      if (outDef.description) {
        lines.push(`  description = "${outDef.description}"`);
      }
      if (outDef.sensitive) {
        lines.push(`  sensitive = true`);
      }
      lines.push('}');
      lines.push('');
    }

    return lines.join('\n');
  }

  // ===========================================================================
  // CloudFormation Generation
  // ===========================================================================

  /**
   * Generate CloudFormation template from resource definitions
   */
  async generateCloudFormation(
    template: InfrastructureTemplate,
    options: CloudFormationGenerationOptions = {}
  ): Promise<CloudFormationGenerationResult> {
    const mergedOptions: CloudFormationGenerationOptions = {
      format: this.config.defaultCloudFormationFormat,
      templateFormatVersion: '2010-09-09',
      includeComments: this.config.includeComments,
      region: this.config.defaultRegion,
      ...options,
    };

    try {
      const warnings: string[] = [];
      const cfnTemplate: Record<string, unknown> = {
        AWSTemplateFormatVersion: mergedOptions.templateFormatVersion,
      };

      if (template.description || mergedOptions.description) {
        cfnTemplate.Description = template.description || mergedOptions.description;
      }

      // Generate parameters
      if (mergedOptions.includeParameters && template.variables) {
        cfnTemplate.Parameters = this.generateCloudFormationParameters(template.variables);
      }

      // Generate resources
      cfnTemplate.Resources = this.generateCloudFormationResources(template.resources, warnings);

      // Generate outputs
      if (template.outputs) {
        cfnTemplate.Outputs = this.generateCloudFormationOutputs(template.outputs);
      }

      // Convert to string
      const templateString = mergedOptions.format === 'yaml'
        ? this.toYaml(cfnTemplate, mergedOptions.includeComments)
        : JSON.stringify(cfnTemplate, null, 2);

      return {
        success: true,
        template: templateString,
        templateObject: cfnTemplate,
        warnings: warnings.length > 0 ? warnings : undefined,
        resourceCount: template.resources.length,
        message: `Successfully generated CloudFormation template with ${template.resources.length} resources`,
      };
    } catch (error) {
      return {
        success: false,
        errors: [String(error)],
        message: `Failed to generate CloudFormation: ${error}`,
      };
    }
  }

  /**
   * Generate CloudFormation parameters
   */
  private generateCloudFormationParameters(
    variables: Record<string, unknown>
  ): Record<string, unknown> {
    const params: Record<string, unknown> = {};

    for (const [name, def] of Object.entries(variables)) {
      const varDef = def as { type?: string; description?: string; default?: unknown };
      const param: Record<string, unknown> = {
        Type: this.toCfnParameterType(varDef.type || 'string'),
      };
      if (varDef.description) param.Description = varDef.description;
      if (varDef.default !== undefined) param.Default = varDef.default;
      params[name] = param;
    }

    return params;
  }

  /**
   * Generate CloudFormation resources
   */
  private generateCloudFormationResources(
    resources: IaCResourceDefinition[],
    warnings: string[]
  ): Record<string, unknown> {
    const cfnResources: Record<string, unknown> = {};

    for (const resource of resources) {
      const cfnResource = this.generateCloudFormationResource(resource, warnings);
      if (cfnResource) {
        cfnResources[this.sanitizeName(resource.name)] = cfnResource;
      }
    }

    return cfnResources;
  }

  /**
   * Generate a single CloudFormation resource
   */
  private generateCloudFormationResource(
    resource: IaCResourceDefinition,
    warnings: string[]
  ): Record<string, unknown> | null {
    const cfnType = this.getCfnResourceType(resource.type);

    if (!cfnType) {
      warnings.push(`Unknown resource type for CloudFormation: ${resource.type}`);
      return null;
    }

    const cfnResource: Record<string, unknown> = {
      Type: cfnType,
      Properties: this.generateCloudFormationProperties(resource),
    };

    if (resource.dependsOn && resource.dependsOn.length > 0) {
      cfnResource.DependsOn = resource.dependsOn.map(d => this.sanitizeName(d));
    }

    return cfnResource;
  }

  /**
   * Generate CloudFormation properties for a resource
   */
  private generateCloudFormationProperties(resource: IaCResourceDefinition): Record<string, unknown> {
    const props: Record<string, unknown> = {};

    switch (resource.type) {
      case 'ec2_instance': {
        const ec2 = resource as EC2InstanceDefinition;
        props.ImageId = ec2.properties.ami;
        props.InstanceType = ec2.properties.instanceType;
        if (ec2.properties.subnetId) props.SubnetId = ec2.properties.subnetId;
        if (ec2.properties.keyName) props.KeyName = ec2.properties.keyName;
        if (ec2.properties.securityGroupIds) props.SecurityGroupIds = ec2.properties.securityGroupIds;
        if (ec2.properties.iamInstanceProfile) props.IamInstanceProfile = ec2.properties.iamInstanceProfile;
        if (ec2.properties.monitoring) props.Monitoring = ec2.properties.monitoring;
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 'ec2_vpc': {
        const vpc = resource as VPCDefinition;
        props.CidrBlock = vpc.properties.cidrBlock;
        if (vpc.properties.enableDnsSupport !== undefined) {
          props.EnableDnsSupport = vpc.properties.enableDnsSupport;
        }
        if (vpc.properties.enableDnsHostnames !== undefined) {
          props.EnableDnsHostnames = vpc.properties.enableDnsHostnames;
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 'ec2_subnet': {
        const subnet = resource as SubnetDefinition;
        props.VpcId = subnet.properties.vpcId;
        props.CidrBlock = subnet.properties.cidrBlock;
        if (subnet.properties.availabilityZone) {
          props.AvailabilityZone = subnet.properties.availabilityZone;
        }
        if (subnet.properties.mapPublicIpOnLaunch !== undefined) {
          props.MapPublicIpOnLaunch = subnet.properties.mapPublicIpOnLaunch;
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 'ec2_security_group': {
        const sg = resource as SecurityGroupDefinition;
        props.GroupName = resource.name;
        props.GroupDescription = sg.properties.description;
        if (sg.properties.vpcId) props.VpcId = sg.properties.vpcId;
        if (sg.properties.ingressRules) {
          props.SecurityGroupIngress = sg.properties.ingressRules.map(r => ({
            IpProtocol: r.protocol,
            FromPort: r.fromPort,
            ToPort: r.toPort,
            CidrIp: r.cidrBlocks?.[0],
            Description: r.description,
          }));
        }
        if (sg.properties.egressRules) {
          props.SecurityGroupEgress = sg.properties.egressRules.map(r => ({
            IpProtocol: r.protocol,
            FromPort: r.fromPort,
            ToPort: r.toPort,
            CidrIp: r.cidrBlocks?.[0],
          }));
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 'rds_instance': {
        const rds = resource as RDSInstanceDefinition;
        props.DBInstanceIdentifier = rds.properties.identifier;
        props.Engine = rds.properties.engine;
        if (rds.properties.engineVersion) props.EngineVersion = rds.properties.engineVersion;
        props.DBInstanceClass = rds.properties.instanceClass;
        props.AllocatedStorage = String(rds.properties.allocatedStorage);
        if (rds.properties.storageType) props.StorageType = rds.properties.storageType;
        props.MasterUsername = rds.properties.username;
        if (rds.properties.password) props.MasterUserPassword = rds.properties.password;
        if (rds.properties.dbName) props.DBName = rds.properties.dbName;
        if (rds.properties.multiAz !== undefined) props.MultiAZ = rds.properties.multiAz;
        if (rds.properties.publiclyAccessible !== undefined) {
          props.PubliclyAccessible = rds.properties.publiclyAccessible;
        }
        if (rds.properties.subnetGroupName) props.DBSubnetGroupName = rds.properties.subnetGroupName;
        if (rds.properties.securityGroupIds) props.VPCSecurityGroups = rds.properties.securityGroupIds;
        if (rds.properties.backupRetentionPeriod !== undefined) {
          props.BackupRetentionPeriod = rds.properties.backupRetentionPeriod;
        }
        if (rds.properties.deletionProtection !== undefined) {
          props.DeletionProtection = rds.properties.deletionProtection;
        }
        if (rds.properties.storageEncrypted !== undefined) {
          props.StorageEncrypted = rds.properties.storageEncrypted;
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 's3_bucket': {
        const s3 = resource as S3BucketDefinition;
        if (s3.properties.bucketName) props.BucketName = s3.properties.bucketName;
        if (s3.properties.versioning) {
          props.VersioningConfiguration = { Status: 'Enabled' };
        }
        if (s3.properties.publicAccessBlock) {
          props.PublicAccessBlockConfiguration = {
            BlockPublicAcls: s3.properties.publicAccessBlock.blockPublicAcls,
            BlockPublicPolicy: s3.properties.publicAccessBlock.blockPublicPolicy,
            IgnorePublicAcls: s3.properties.publicAccessBlock.ignorePublicAcls,
            RestrictPublicBuckets: s3.properties.publicAccessBlock.restrictPublicBuckets,
          };
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 'lambda_function': {
        const lambda = resource as LambdaFunctionDefinition;
        props.FunctionName = lambda.properties.functionName;
        props.Runtime = lambda.properties.runtime;
        props.Handler = lambda.properties.handler;
        props.Role = lambda.properties.role;
        if (lambda.properties.s3Bucket && lambda.properties.s3Key) {
          props.Code = {
            S3Bucket: lambda.properties.s3Bucket,
            S3Key: lambda.properties.s3Key,
          };
        }
        if (lambda.properties.memorySize) props.MemorySize = lambda.properties.memorySize;
        if (lambda.properties.timeout) props.Timeout = lambda.properties.timeout;
        if (lambda.properties.environment) {
          props.Environment = { Variables: lambda.properties.environment };
        }
        if (lambda.properties.layers) props.Layers = lambda.properties.layers;
        if (lambda.properties.vpcConfig) {
          props.VpcConfig = {
            SubnetIds: lambda.properties.vpcConfig.subnetIds,
            SecurityGroupIds: lambda.properties.vpcConfig.securityGroupIds,
          };
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      case 'iam_role': {
        const iam = resource as IAMRoleDefinition;
        props.RoleName = iam.properties.name;
        props.AssumeRolePolicyDocument = typeof iam.properties.assumeRolePolicy === 'string'
          ? JSON.parse(iam.properties.assumeRolePolicy)
          : iam.properties.assumeRolePolicy;
        if (iam.properties.description) props.Description = iam.properties.description;
        if (iam.properties.managedPolicyArns) {
          props.ManagedPolicyArns = iam.properties.managedPolicyArns;
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
        break;
      }

      default:
        // Generic property mapping with PascalCase conversion
        for (const [key, value] of Object.entries(resource.properties)) {
          props[this.toPascalCase(key)] = value;
        }
        if (resource.tags) {
          props.Tags = Object.entries(resource.tags).map(([k, v]) => ({ Key: k, Value: v }));
        }
    }

    return props;
  }

  /**
   * Generate CloudFormation outputs
   */
  private generateCloudFormationOutputs(outputs: Record<string, unknown>): Record<string, unknown> {
    const cfnOutputs: Record<string, unknown> = {};

    for (const [name, def] of Object.entries(outputs)) {
      const outDef = def as { value: string; description?: string; export?: boolean };
      const output: Record<string, unknown> = {
        Value: outDef.value,
      };
      if (outDef.description) output.Description = outDef.description;
      if (outDef.export) {
        output.Export = { Name: name };
      }
      cfnOutputs[name] = output;
    }

    return cfnOutputs;
  }

  // ===========================================================================
  // Drift Detection
  // ===========================================================================

  /**
   * Detect drift between IaC definitions and deployed resources
   */
  async detectDrift(options: DriftDetectionOptions = {}): Promise<DriftDetectionResult> {
    try {
      const drifts: ResourceDrift[] = [];
      let inSyncCount = 0;
      let driftedCount = 0;
      let deletedCount = 0;

      // This is a simplified implementation
      // In production, this would:
      // 1. Parse the IaC files (Terraform state or CloudFormation stack)
      // 2. Query AWS for actual resource configurations
      // 3. Compare and detect differences

      // For now, return a placeholder result
      // The actual implementation would integrate with AWS Config or 
      // CloudFormation drift detection APIs

      const message = options.iacPath
        ? `Drift detection completed for ${options.iacPath}`
        : 'Drift detection completed';

      return {
        success: true,
        timestamp: new Date(),
        status: driftedCount > 0 ? 'drifted' : 'clean',
        totalResources: inSyncCount + driftedCount + deletedCount,
        inSyncCount,
        driftedCount,
        deletedCount,
        drifts,
        message,
      };
    } catch (error) {
      return {
        success: false,
        timestamp: new Date(),
        status: 'error',
        totalResources: 0,
        inSyncCount: 0,
        driftedCount: 0,
        deletedCount: 0,
        drifts: [],
        errors: [String(error)],
        message: `Drift detection failed: ${error}`,
      };
    }
  }

  // ===========================================================================
  // State Export
  // ===========================================================================

  /**
   * Export existing AWS infrastructure to IaC format
   */
  async exportState(options: StateExportOptions): Promise<StateExportResult> {
    try {
      const warnings: string[] = [];
      const resources: DiscoveredResource[] = [];

      // This would discover resources from AWS
      // For now, return a template that can be used

      if (resources.length === 0) {
        return {
          success: true,
          resourceCount: 0,
          resources: [],
          warnings: ['No resources found to export. Specify resource IDs or types to export.'],
          message: 'No resources discovered for export',
        };
      }

      // Convert discovered resources to IaC
      const template: InfrastructureTemplate = {
        name: 'exported-infrastructure',
        description: 'Infrastructure exported from AWS',
        resources: resources.map(r => ({
          type: r.resourceType,
          name: r.resourceId.replace(/[^a-zA-Z0-9]/g, '_'),
          properties: r.properties,
          tags: r.tags,
          region: r.region,
        })),
      };

      let iacCode: string;
      let files: Record<string, string> | undefined;

      if (options.format === 'terraform') {
        const result = await this.generateTerraform(template, options.terraformOptions);
        iacCode = result.mainTf || '';
        files = result.files;
        if (result.warnings) warnings.push(...result.warnings);
      } else {
        const result = await this.generateCloudFormation(template, options.cloudFormationOptions);
        iacCode = result.template || '';
        if (result.warnings) warnings.push(...result.warnings);
      }

      // Generate import commands for Terraform
      const importCommands = options.format === 'terraform'
        ? resources.map(r => `terraform import ${this.getAWSResourceType(r.resourceType)}.${r.resourceId.replace(/[^a-zA-Z0-9]/g, '_')} ${r.resourceId}`)
        : undefined;

      return {
        success: true,
        resourceCount: resources.length,
        resources,
        iacCode,
        files,
        importCommands,
        warnings: warnings.length > 0 ? warnings : undefined,
        message: `Successfully exported ${resources.length} resources to ${options.format}`,
      };
    } catch (error) {
      return {
        success: false,
        resourceCount: 0,
        errors: [String(error)],
        message: `Failed to export state: ${error}`,
      };
    }
  }

  // ===========================================================================
  // Plan & Apply (Placeholder - would integrate with actual Terraform/CFN)
  // ===========================================================================

  /**
   * Generate a plan for infrastructure changes
   */
  async planChanges(
    template: InfrastructureTemplate,
    _options: { format: 'terraform' | 'cloudformation'; region?: string } = { format: 'terraform' }
  ): Promise<InfrastructurePlan> {
    try {
      // In production, this would:
      // 1. Generate the IaC code
      // 2. Run `terraform plan` or create a CloudFormation change set
      // 3. Parse the output to extract planned changes

      const toCreate: ResourceChange[] = template.resources.map(r => ({
        resourceType: r.type,
        logicalName: r.name,
        action: 'create' as const,
      }));

      return {
        success: true,
        timestamp: new Date(),
        toCreate,
        toUpdate: [],
        toDelete: [],
        unchanged: 0,
        totalResources: template.resources.length,
        message: `Plan: ${toCreate.length} to create, 0 to update, 0 to delete`,
      };
    } catch (error) {
      return {
        success: false,
        timestamp: new Date(),
        toCreate: [],
        toUpdate: [],
        toDelete: [],
        unchanged: 0,
        totalResources: 0,
        errors: [String(error)],
        message: `Failed to generate plan: ${error}`,
      };
    }
  }

  /**
   * Apply infrastructure changes (with approval workflow)
   */
  async applyChanges(
    _plan: InfrastructurePlan,
    _options: ApplyOptions = {}
  ): Promise<ApplyResult> {
    // This is a placeholder - actual implementation would:
    // 1. Validate approval if required
    // 2. Run `terraform apply` or execute CloudFormation stack
    // 3. Track progress and report results

    return {
      success: false,
      timestamp: new Date(),
      created: 0,
      updated: 0,
      deleted: 0,
      failed: 0,
      errors: ['Apply operations require approval workflow configuration. Use the generated IaC files with your preferred deployment method.'],
      message: 'Direct apply not enabled. Export IaC and deploy using your CI/CD pipeline.',
    };
  }

  // ===========================================================================
  // Helper Methods
  // ===========================================================================

  /**
   * Get Terraform resource type from internal type
   */
  private getAWSResourceType(type: AWSResourceType): string | null {
    const mapping: Record<AWSResourceType, string> = {
      ec2_instance: 'aws_instance',
      ec2_security_group: 'aws_security_group',
      ec2_key_pair: 'aws_key_pair',
      ec2_vpc: 'aws_vpc',
      ec2_subnet: 'aws_subnet',
      ec2_internet_gateway: 'aws_internet_gateway',
      ec2_nat_gateway: 'aws_nat_gateway',
      ec2_route_table: 'aws_route_table',
      ec2_eip: 'aws_eip',
      rds_instance: 'aws_db_instance',
      rds_cluster: 'aws_rds_cluster',
      rds_subnet_group: 'aws_db_subnet_group',
      rds_parameter_group: 'aws_db_parameter_group',
      s3_bucket: 'aws_s3_bucket',
      s3_bucket_policy: 'aws_s3_bucket_policy',
      lambda_function: 'aws_lambda_function',
      lambda_layer: 'aws_lambda_layer_version',
      iam_role: 'aws_iam_role',
      iam_policy: 'aws_iam_policy',
      iam_instance_profile: 'aws_iam_instance_profile',
      alb: 'aws_lb',
      alb_target_group: 'aws_lb_target_group',
      alb_listener: 'aws_lb_listener',
      asg: 'aws_autoscaling_group',
      launch_template: 'aws_launch_template',
      cloudwatch_alarm: 'aws_cloudwatch_metric_alarm',
      cloudwatch_log_group: 'aws_cloudwatch_log_group',
      sns_topic: 'aws_sns_topic',
      sqs_queue: 'aws_sqs_queue',
      dynamodb_table: 'aws_dynamodb_table',
      elasticache_cluster: 'aws_elasticache_cluster',
      kms_key: 'aws_kms_key',
    };

    return mapping[type] || null;
  }

  /**
   * Get CloudFormation resource type from internal type
   */
  private getCfnResourceType(type: AWSResourceType): string | null {
    const mapping: Record<AWSResourceType, string> = {
      ec2_instance: 'AWS::EC2::Instance',
      ec2_security_group: 'AWS::EC2::SecurityGroup',
      ec2_key_pair: 'AWS::EC2::KeyPair',
      ec2_vpc: 'AWS::EC2::VPC',
      ec2_subnet: 'AWS::EC2::Subnet',
      ec2_internet_gateway: 'AWS::EC2::InternetGateway',
      ec2_nat_gateway: 'AWS::EC2::NatGateway',
      ec2_route_table: 'AWS::EC2::RouteTable',
      ec2_eip: 'AWS::EC2::EIP',
      rds_instance: 'AWS::RDS::DBInstance',
      rds_cluster: 'AWS::RDS::DBCluster',
      rds_subnet_group: 'AWS::RDS::DBSubnetGroup',
      rds_parameter_group: 'AWS::RDS::DBParameterGroup',
      s3_bucket: 'AWS::S3::Bucket',
      s3_bucket_policy: 'AWS::S3::BucketPolicy',
      lambda_function: 'AWS::Lambda::Function',
      lambda_layer: 'AWS::Lambda::LayerVersion',
      iam_role: 'AWS::IAM::Role',
      iam_policy: 'AWS::IAM::Policy',
      iam_instance_profile: 'AWS::IAM::InstanceProfile',
      alb: 'AWS::ElasticLoadBalancingV2::LoadBalancer',
      alb_target_group: 'AWS::ElasticLoadBalancingV2::TargetGroup',
      alb_listener: 'AWS::ElasticLoadBalancingV2::Listener',
      asg: 'AWS::AutoScaling::AutoScalingGroup',
      launch_template: 'AWS::EC2::LaunchTemplate',
      cloudwatch_alarm: 'AWS::CloudWatch::Alarm',
      cloudwatch_log_group: 'AWS::Logs::LogGroup',
      sns_topic: 'AWS::SNS::Topic',
      sqs_queue: 'AWS::SQS::Queue',
      dynamodb_table: 'AWS::DynamoDB::Table',
      elasticache_cluster: 'AWS::ElastiCache::CacheCluster',
      kms_key: 'AWS::KMS::Key',
    };

    return mapping[type] || null;
  }

  /**
   * Convert CloudFormation parameter type
   */
  private toCfnParameterType(type: string): string {
    const mapping: Record<string, string> = {
      string: 'String',
      number: 'Number',
      boolean: 'String', // CFN doesn't have boolean, use String with allowed values
      list: 'CommaDelimitedList',
      map: 'String', // JSON string
    };
    return mapping[type.toLowerCase()] || 'String';
  }

  /**
   * Sanitize name for use in IaC (Terraform uses underscores)
   */
  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
  }

  /**
   * Convert camelCase to snake_case
   */
  private toSnakeCase(str: string): string {
    return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
  }

  /**
   * Convert camelCase to PascalCase
   */
  private toPascalCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Simple YAML serializer (for CloudFormation)
   */
  private toYaml(obj: Record<string, unknown>, includeComments?: boolean): string {
    const lines: string[] = [];

    if (includeComments) {
      lines.push('# CloudFormation Template');
      lines.push('# Generated by Espada AWS Extension');
      lines.push('');
    }

    const serialize = (value: unknown, indent: number = 0): void => {
      const prefix = '  '.repeat(indent);

      if (value === null || value === undefined) {
        return;
      }

      if (Array.isArray(value)) {
        for (const item of value) {
          if (typeof item === 'object' && item !== null) {
            lines.push(`${prefix}-`);
            for (const [k, v] of Object.entries(item)) {
              if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
                lines.push(`${prefix}  ${k}:`);
                serialize(v, indent + 2);
              } else if (Array.isArray(v)) {
                lines.push(`${prefix}  ${k}:`);
                serialize(v, indent + 2);
              } else {
                lines.push(`${prefix}  ${k}: ${this.yamlValue(v)}`);
              }
            }
          } else {
            lines.push(`${prefix}- ${this.yamlValue(item)}`);
          }
        }
      } else if (typeof value === 'object') {
        for (const [k, v] of Object.entries(value as Record<string, unknown>)) {
          if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
            lines.push(`${prefix}${k}:`);
            serialize(v, indent + 1);
          } else if (Array.isArray(v)) {
            lines.push(`${prefix}${k}:`);
            serialize(v, indent + 1);
          } else {
            lines.push(`${prefix}${k}: ${this.yamlValue(v)}`);
          }
        }
      }
    };

    serialize(obj);
    return lines.join('\n');
  }

  /**
   * Format value for YAML
   */
  private yamlValue(value: unknown): string {
    if (value === null || value === undefined) return 'null';
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return String(value);
    if (typeof value === 'string') {
      // Quote strings that might be interpreted as other types
      if (/^[0-9]/.test(value) || /^(true|false|null|yes|no)$/i.test(value) || value.includes(':') || value.includes('#')) {
        return `"${value.replace(/"/g, '\\"')}"`;
      }
      return value;
    }
    return JSON.stringify(value);
  }
}

// =============================================================================
// Factory Function
// =============================================================================

/**
 * Create an IaC Manager instance
 */
export function createIaCManager(config: IaCManagerConfig = {}): IaCManager {
  return new IaCManager(config);
}
